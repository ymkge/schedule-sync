# Schedule Sync (スケジュール同期アプリ) 

Schedule Syncは、CalendlyやSpirのような日程調整アプリケーションです。あなたのGoogleカレンダーと連携し、空き時間を自動的に見つけ出し、他の人が簡単に会議を予約できるユニークな共有リンクを提供します。

## 主な機能 

- **Googleカレンダー連携**: OAuth 2.0を使用して、安全にGoogleカレンダーに接続します。
- **空き時間の自動生成**: カレンダーの予定やあらかじめ設定した稼働時間に基づき、予約可能な時間枠を自動で計算します。
- **共有可能な予約リンク**: あなた専用の予約ページのユニークなURLを生成します。
- **ワンクリック予約**: 面倒なやり取りなしに、数クリックで予約が完了します。
- **会議リンクの自動発行**: 予約されたイベントごとに、Google Meetの会議リンクが自動で作成されます。
- **ダブルブッキング防止**: ある時間枠が予約されると、他の人が同じ時間を予約することはできません。

## 技術スタック

- **フロントエンド**: Next.js, React, TypeScript, Tailwind CSS
- **バックエンド**: Python, FastAPI
- **データベース**: Google Cloud Firestore
- **API・認証**: Google Calendar API, Google People API, Google OAuth 2.0
- **デプロイ環境 (計画)**: Docker, Google Cloud Run

## プロジェクト構造

```
/schedule-sync
├── /backend/      # FastAPI アプリケーション (バックエンド)
└── /frontend/     # Next.js アプリケーション (フロントエンド)
```

## ローカル開発環境のセットアップ

### 前提条件

- Node.js (v18 以上)
- Python (v3.9 以上)
- Google Cloud プロジェクトが作成済みであること
- `gcloud` CLI がインストール・認証済みであること
- Google Cloud プロジェクトで **Cloud Firestore API が有効化済み** であること

### 1. バックエンドのセットアップ

1.  **バックエンドディレクトリに移動します:**
    ```bash
    cd backend
    ```

2.  **必要なライブラリをインストールします:**
    ```bash
    pip install -r requirements.txt
    ```

3.  **Google Cloudの認証情報を設定します:**
    - Google Cloudコンソールで、「ウェブアプリケーション」用の **OAuth 2.0 クライアント ID** を作成します。
    - 「承認済みのリダイレクト URI」に `http://localhost:8080/api/auth/callback` を追加します。
    - 発行された `クライアント ID` と `クライアント シークレット` を控えておきます。

4.  **環境変数を設定します:**
    - `.env.example` をコピーして `.env` ファイルを作成します: `cp .env.example .env`
    - `.env` ファイルを以下のように編集します:
        - `GOOGLE_CLIENT_ID` と `GOOGLE_CLIENT_SECRET` に、先ほど取得した値を設定します。
        - `SECRET_KEY` の値を、ターミナルで以下のコマンドを実行して生成されたキーに置き換えます。
          ```bash
          python3 -c "import base64, os; print(base64.urlsafe_b64encode(os.urandom(32)).decode())"
          ```
        - ローカル開発で `http://` を使うために、ファイルの末尾に以下の行を追加します。
          ```
          OAUTHLIB_INSECURE_TRANSPORT=1
          ```

5.  **アプリケーションのデフォルト認証情報を設定します:**
    これにより、バックエンドがFirestoreなどのGoogle Cloudサービスにアクセスできるようになります。
    ```bash
    gcloud auth application-default login
    ```
    - **[トラブルシューティング]** もし後の手順で `Project was not passed` というエラーが出た場合は、`gcloud config set project YOUR_PROJECT_ID` を実行して、使用するプロジェクトを明示的に設定してください。

6.  **Firestore データベースを作成します:**
    - 初回セットアップ時のみ、データを保存するためのデータベースを作成する必要があります。
    - [こちらのリンク](https://console.cloud.google.com/firestore) から、あなたのプロジェクトのFirestoreページを開きます。
    - 「データベースの作成」をクリックします。
    - **モード**: 「**ネイティブ モード**」を選択します。
    - **ロケーション**: 「**asia-northeast1 (Tokyo)**」など、任意の場所を選択します。
    - 「データベースを作成」をクリックします。

7.  **バックエンドサーバーを起動します:**
    ```bash
    uvicorn main:app --reload --port 8080
    ```

### 2. フロントエンドのセットアップ

(フロントエンドのセットアップ手順は変更ありません)

1.  **フロントエンドディレクトリに移動します:**
    ```bash
    cd frontend
    ```

2.  **必要なライブラリをインストールします:**
    ```bash
    npm install
    ```

3.  **フロントエンドサーバーを起動します:**
    ```bash
    npm run dev
    ```
    アプリケーションが `http://localhost:3000` で利用可能になります。

## 利用方法

1.  **ログイン**: トップページにアクセスし、Googleアカウントでログインします。
2.  **カレンダー同期**: ログイン後、ダッシュボード（今後実装予定）でカレンダーを同期し、予約可能なスロットを生成します。
3.  **リンク共有**: あなた専用の予約リンク（例: `http://localhost:3000/<あなたの公開トークン>`）を他の人に共有します。
4.  **予約受付**: 共有された相手はリンクにアクセスし、空いている時間を選んで予約します。予約内容は自動的にあなたのGoogleカレンダーに登録されます。

## 今後の開発タスク (Next Steps)

基本的な認証フロー（ログイン・ログアウト・状態保持）は完成しましたが、ログイン後のユーザーが実際にカレンダーを同期する機能は未実装です。
次回は、以下のタスクに取り組みます。

### 1. バックエンドのタスク

- **目的**: APIが、どのユーザーからのリクエストかを「通行証（JWTトークン）」によって安全に識別できるようにする。
- **作業**: 
    1.  HTTPヘッダーに含まれる `Authorization: Bearer <token>` からトークンを読み取り、それを検証してユーザーIDを特定する、FastAPIの認証ロジック（`Depends`を使用）を実装します。
    2.  `/api/user/me/slots` エンドポイントを修正し、リクエストのボディからではなく、上記1の認証ロジックからユーザーIDを取得するように変更します。

### 2. フロントエンドのタスク

- **目的**: ログイン後のユーザーが、ボタン操作で自分のカレンダー同期を実行できるようにする。
- **作業**:
    1. `app/page.tsx` のログイン後の画面に、「カレンダーを同期する」ボタンを追加します。
    2. ボタンがクリックされた際に、ブラウザに保管した「通行証（JWTトークン）」を取得します。
    3. `Authorization: Bearer <token>` という形式でHTTPヘッダーにトークンを設定し、バックエンドの `/api/user/me/slots` APIにリクエストを送信する処理を実装します。
    4. APIからの応答（「同期が完了しました」などのメッセージ）を画面に表示します。

## ライセンス

このプロジェクトは **MITライセンス** の下で公開されています。詳細は [LICENSE](LICENSE) ファイルをご覧ください。